{"./":{"url":"./","title":"前言","keywords":"","body":"Introduction Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 18:28 "},"tut/chapter0.0.html":{"url":"tut/chapter0.0.html","title":"What is Prolog","keywords":"","body":"PROLOG简介 人工智能语言是一类适应于人工智能和知识工程领域的、具有符号处理和逻辑推理能力的计算机程序设计语言,其中Prolog是当代最有影响的人工智能语言之一。 什么是人工智能语言 人工智能（AI）语言是一类适应于人工智能和知识工程领域的、具有符号处理和逻辑推理能力的计算机程序设计语言。能够用它来编写程序求解非数值计算、知识处理、推理、规划、决策等具有智能的各种复杂问题。 典型的人工智能语言主要有LISP、Prolog、Smaltalk、C++等。 一般来说，人工智能语言应具备如下特点： 具有符号处理能力（即非数值处理能力）; 适合于结构化程序设计，编程容易; 具有递归功能和回溯功能; 具有人机交互能力; 适合于推理; 既有把过程与说明式数据结构混合起来的能力，又有辨别数据、确定控制的模式匹配机制。 人们可能会问，用人工智能语言解决问题与传统的方法有什么区别呢？ 传统方法通常把问题的全部知识以各种的模型表达在固定程序中，问题的求解完全在程序制导下按着预先安排好的步骤一步一步（逐条）执行。解决问题的思路与冯.诺依曼式计算机结构相吻合。当前大型数据库法、数学模型法、统计方法等都是严格结构化的方法。 对于人工智能技术要解决的问题，往往无法把全部知识都体现在固定的程序中。通常需要建立一个知识库（包含事实和推理规则），程序根据环境和所给的输入信息以及所要解决的问题来决定自己的行动，所以它是在环境模式的制导下的推理过程。这种方法有极大的灵活性、对话能力、有自我解释能力和学习能力。这种方法对解决一些条件和目标不大明确或不完备，（即不能很好地形式化，不好描述）的非结构化问题比传统方法好，它通常采用启发式、试探法策略来解决问题。 Prolog语言及其基本结构 Prolog是当代最有影响的人工智能语言之一，由于该语言很适合表达人的思维和推理规则，在自然语言理解、机器定理证明、专家系统等方面得到了广泛的应用，已经成为人工智能应用领域的强有力的开发语言。 尽管Prolog语言有许多版本，但它们的核心部分都是一样的。Prolog的基本语句仅有三种，即事实、规则和目标三种类型的语句，且都用谓词表示，因而程序逻辑性强，文法简捷，清晰易懂。另一方面，Prolog是陈述性语言，一旦给它提交必要的事实和规则之后，Prolog就使用内部的演绎推理机制自动求解程序给定的目标，而不需要在程序中列出详细的求解步骤。 事实 事实用来说明一个问题中已知的对象和它们之间的关系。在Prolog程序中，事实由谓词名及用括号括起来的一个或几个对象组成。谓词和对象可由用户自己定义。 例如，谓词likes(bill，book). 是一个名为like的关系，表示对象bill和book之间有喜欢的关系。 规则 规则由几个互相有依赖性的简单句（谓词）组成，用来描述事实之间的依赖关系。从形式上看，规则由左边表示结论的后件谓词和右边表示条件的前提谓词组成。 例如，规则 bird(X):-animal(X),has(X,feather). 表示凡是动物并且有羽毛，那么它就是鸟。 目标（问题） 把事实和规则写进Prolog程序中后，就可以向Prolog询问有关问题的答案，询问的问题就是程序运行的目标。目标的结构与事实或规则相同，可以是一个简单的谓词，也可以是多个谓词的组合。目标分内、外两种，内部目标写在程序中，外部目标在程序运行时由用户手工键入。 例如问题 ?-student(john). 表示“john是学生吗？” 简单例子 以下两个例子在Swi-Prolog环境下运行通过。 例1 谁是john的朋友？ likes(bell,sports). likes(mary,music). likes(mary,sports). likes(jane,smith). friend(john,X):- likes(X,sports), likes(X,music). 当上述事实与规则输入计算机后，运行该程序，用户就可以进行询问，如输入目标： friend(john,X) 即询问john的朋友是谁,,这时计算机的运行结果为： X=mary //（mary是john的朋友） 例2 汉诺塔问题： 有N个有孔的盘子，最初这些盘子都叠放在柱a上，要求将这N个盘子借助柱b从柱a移到柱c，移动时有以下限制：每次只能移动一个盘子;大盘不能放在小盘上。问如何移动？ 该问题可以采用递归法思想来求解,其源程序为: move(1,X,Y,_) :- write('Move top disk from '), write(X), write(' to '), write(Y), nl. move(N,X,Y,Z) :- N>1, M is N-1, move(M,X,Z,Y), move(1,X,Y,_), move(M,Z,Y,X). 这里调用比较特殊move(3,left,right,center).，代表了标准的汉诺塔在最左边放了三个盘子，并给每个杆子命名为left right center.(这里换成更多的4 5 6都是可以的，但是杆子命名不能相同) 输出 Move top disk from left to right Move top disk from left to center Move top disk from right to center Move top disk from left to right Move top disk from center to left Move top disk from center to right Move top disk from left to right Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 18:04 "},"tut/chapter0.1.html":{"url":"tut/chapter0.1.html","title":"环境配置","keywords":"","body":"Prolog语言的常用版本 Prolog语言最早是由法国马赛大学的Colmerauer和他的研究小组于1972年研制成功。早期的Prolog版本都是解释型的，自1986年美国Borland公司推出编译型Prolog,即Turbo Prolog以后，Prolog便很快在PC机上流行起来。后来又经历了PDC PROLOG、Visual Prolog不同版本的发展。并行的逻辑语言也于80年代初开始研制，其中比较著名的有PARLOG、Concurrent PROLOG等。 SWI-Prolog (特别推荐) SWI-Prolog offers a comprehensive free Prolog environment. Since its start in 1987, SWI-Prolog development has been driven by the needs of real world applications. SWI-Prolog is widely used in research and education as well as commercial applications. Join over a million users who have downloaded SWI-Prolog. http://www.swi-prolog.org/ online prolog shell 这个在线编译器很好用，并且有非常丰富的例子，且一直在持续更新，github有上百star (swipl特别想推广它的web库...这个笔者就不太感冒了) Turbo Prolog 由美国Prolog开发中心（Prolog Development Center, PDC）1986年开发成功、Borland公司对外发行，其1.0，2.0，2.1版本取名为Turbo Prolog，主要在IBM PC系列计算机，MS-DOS环境下运行。 PDC Prolog 1990年后，PDC推出新的版本，更名为PDC Prolog 3.0，3.2，它把运行环境扩展到OS/2操作系统，并且向全世界发行。它的主要特点是: 速度快。编译及运行速度都很快，产生的代码非常紧凑。 用户界面友好。提供了图形化的集成开发环境。 提供了强有力的外部数据库系统。 提供了一个用PDC Prolog编写的Prolog解释起源代码。用户可以用它研究Prolog的内部机制，并创建自己的专用编程语言、推理机、专家系统外壳或程序接口。 提供了与其他语言（如C、Pascal、Fortran等）的接口。Prolog和其他语言可以相互调用对方的子程序。 具有强大的图形功能。支持Turbo C、Turbo Pascal同样的功能。 Visual Prolog Visual Prolog是基于Prolog语言的可视化集成开发环境，是PDC推出的基于Windows环境的智能化编程工具。目前，Visual Prolog在美国、西欧、日本、加拿大、澳大利亚等国家和地区十分流行，是国际上研究和开发智能化应用的主流工具之一。 Visual Prolog具有模式匹配、递归、回溯、对象机制、事实数据库和谓词库等强大功能。它包含构建大型应用程序所需要的一切特性：图形开发环境、编译器、连接器和调试器，支持模块化和面向对象程序设计，支持系统级编程、文件操作、字符串处理、位级运算、算术与逻辑运算，以及与其它编程语言的接口。 Visual Prolog包含一个全部使用Visual Prolog语言写成的有效的开发环境，包含对话框、菜单、工具栏等编辑功能。 Visual Prolog与SQL数据库系统、C++开发系统、以及Visual Basic、Delphi或Visual Age等编程语言一样，也可以用来轻松地开发各种应用。 Visual Prolog软件的下载地址为：http://www.visual-prolog.com。 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"tut/chapter0.2.html":{"url":"tut/chapter0.2.html","title":"动手试试","keywords":"","body":"动手试试 prolog-使用逻辑编程语言的教程，第一章主要包括概述和前言，什么是Prolog，为什么要使用Prolog等。 如果你是一位prolog的新手，希望你首先阅读这篇文章，好对prolog的全局有个了解。在这篇文章中我会把prolog和其他的程序语言做比较，所以希望你已经具有了一定的编程水平。 什么是prolog？ prolog是Programming in LOGic的缩写，意思就是使用逻辑的语言编写程序。prolog不是很高深的语言，相反，比较起其他的一些程序语言，例如c、basic等等语言，prolog是更加容易理解的语言。如果你从来没有接触过计算机编程，那么恭喜你，你将很容易的进入prolog世界。如果你已经是其他语言的高手，你就需要完全丢弃你原来的编程思路，否则是很难掌握prolog的。 Demo 谁又爱了谁 逻辑思维在我们日常生活中比比皆是，prolog正是把这种思维用文字描述出来的计算机语言。还是首先举个例子吧。 比如一群年轻人正在恋爱，每个人都有自己心中所追求的对象： 张学友爱王菲 张学友爱周慧敏 王菲爱谢廷峰 周慧敏爱张学友 谢廷峰爱王菲 谢廷峰爱周慧敏 刘德华爱周慧敏 ...... 我们说两个年轻人要互相都喜爱，他们就算是一对情侣，那么上面的谁和谁是情侣呢？ 这应该算是一道最简单逻辑推理题目了，那么我们如何用prolog语言实现呢？ “张学友爱王菲”是一条已知的事实 用prolog语言来表达就是： 爱(张学友,王菲). 注意1：这里是为了阅读方便才使用汉字的，真正的prolog是不允许使用除了基本字符以外字符的，也就是说，上面的句子必须写成love(zhangxueyou,wanfei).，电脑才能够真正的理解。 swipl是支持所有编码的，如果使用在线编辑器的话几乎无障碍 如果是用idle在代码里需要声明编码格式，详见代码 之后的所有代码我都尽量分为两份，一份是文中原样使用ascii英文表述的 另一份以_cn结尾的就是基于utf-8的中文代码 （如果能直观表达我都尝试用中文写一遍） 注意2：最末尾的.一定不能掉，它表示一个句子结束。 注意3：上面词汇对于电脑来说并没有真正的含义，所以我们完全可以用ai(zxy,wf).来表达这个关系，更进一步，我们甚至可以用xxx(a,b).来表达，只要你自己心里清楚xxx表示爱，a表示张学友，b表示王菲就可以了。 注意4：张学友和王菲的顺序也没有特别的规定，你完全可以把他们换个位置：爱(王菲,张学友).只要你心里清楚它表达的意思就行了，而以后都遵循这种被爱的人在前面的顺序，就不会出错。 其他的事实我就不写了，你可以参照上面的例子自己把已知事实翻译成prolog的语句。 那么情侣的概念怎么定义呢？也很简单！ 情侣(某人甲,某人乙):- 爱(某人甲,某人乙), 爱(某人乙,某人甲). :-在prolog中表示“如果”的意思，我们使用它来定义规则。上面这句话的意思就是，某人甲和某人乙是情侣的规则就是：某人甲爱某人乙，并且某人乙爱某人甲。上面用来分隔两个爱的句子的,表示并且的意思。 当然为了能够让电脑运行，这个句子要改为英文的： lovers(X,Y):-love(X,Y),love(Y,X). 注意：在prolog中以小写字符开头的字符串代表确知的事物，比如love表示爱这种关系，而zhangxueyou表示张学友。而以大写字母开头的字符串表示未确定的事物，翻译成汉语就是某某。 完整的可运行的prolog程序如下：（我的拼音不好，要是什么人的名字拼写错了，请原谅：） love(zhangxueyou,wanfei). love(zhangxueyou,zouhuimin). love(wanfei,xietinfen). love(zouhuimin,zhangxueyou). love(xietinfen,wanfei). love(xietinfen,zouhuimin). love(liudehua,zouhuimin). lovers(X,Y):-love(X,Y),love(Y,X). 我们可以看出来，完整的prolog程序是有事实和规则组成的。事实用来储存一些数据，而规则用来储存某种可以推理出来的关系。 如果把上面的程序调入prolog解释器（关于prolog解释器，在后面有介绍）然后就可以对以上的程序进行询问。 prolog解释器的提示符号为“?-”，你只需要在在这个提示符后面输入自己的句子就可以了。让我们来看第一个询问： ?-love(zhangxueyou,wanfei). 事实上我们的询问完全和程序中的第一条事实一样，这个询问是“是非”询问，也就是说电脑回答的答案是yes或者no。上面的询问的含义是：就你所知，张学友爱王菲么？由于我们的程序中间有这样的事实，所以解释器将回答。 yes. 如果我们问： ?-love(zhangxueyou,liudehua). 解释器将回答 no. 因为它没有发现love(zhangxueyou,liudehua).这个事实。 在询问中我们可以使用大写字母代表未知的事物，让解释器找到答案。例如： ?-love(zhangxueyou,X). 这句话询问的是：张学友都喜欢那些人。解释器将给出答案： X = wanfei; X = zouhuimin; no. 注意1：上面的两个;是人工输入的，当解释器找到一个答案之后，它将这个答案输出，并且等待用户的进一步输入，如果用户输入“；”，解释器将继续寻找其他的答案，如果输入的是别的符号，解释器将终止查询。 最后那个no.是因为，系统在输出了zouhuimin这个答案以后，用户输入“；”，表示还想知道其他的答案，而解释器又找不到其他的答案了，于是输出no.来终止查询。我们再看一个例子： ?-love(X,zouhuimin). X=zhangxueyou; X=xietinfen; X=liudehua; no. 在上面的询问中，我们只涉及到对事实的查询，下面我们来看规则的用法。 ?- lovers(X,Y). X = zhangxueyou Y = zouhuimin ; X = wanfei Y = xietinfen ; X = zouhuimin Y = zhangxueyou ; X = xietinfen Y = wanfei ; no 我们看到lovers(X,Y).找出了系统中所有的恋人。不过每对恋人被显示了两次，这是因为prolog是考虑顺序的，也就是说lovers(a,b).和lovers(b,a).并不等价。这一点在后面的学习中，你会了解。 谁是情敌！ ?- lovers(wanfei,Y). Y = xietinfen ; no 询问王菲的恋人，结果是xietinfen。呵呵，还挺聪明的。我们看到同样是lovers，根据其参数不同，功能也不同，这也是prolog的一个大特点。 最后让我们编写一个寻找情敌的规则来结束这一节内容吧。 rival_in_love(X,Y):- love(X,Z), not(love(Z,X)), love(Z,Y). 这段程序可以理解为：Y是X的情敌的条件是：X喜欢Z(代表某个人)，而Z不喜欢X，而Y是Z喜欢的人。哈哈，这不正是情敌的条件嘛。 ?- rival_in_love(X,Y). X = zhangxueyou Y = xietinfen ; X = xietinfen Y = zhangxueyou ; X = liudehua Y = zhangxueyou ; no 好了，你自己分析一下为什么会是这样的答案吧。 为什么要prolog 看完上面的例子，不知道是否提起了你对prolog的兴趣。如果你感兴趣的话，那么让我们继续来看prolog能够做一些什么事情吧。 理论上来说使用c语言可以编制任何种类的程序，甚至连prolog语言都是使用c语言编写的。不过对于急于开发应用程序的用户，最关心的是如何最经济最有效率的开发程序，prolog为你多提供了一个选择的余地。 prolog很适合于开发有关人工智能方面的程序，例如：专家系统、自然语言理解、定理证明以及许多智力游戏。曾经有人预言prolog将成为下一代计算机的主要语言，虽然这个梦想目前还很难实现，不过世界上已经有许多prolog的应用实例了。你要坚信，它绝对不是那种只在实验室发挥作用的语言，之所以大多数人都不了解它，是因为它的应用范围比较特殊而已。 prolog有许多不足之处，但是这并不影响它在逻辑推理方面的强大功能，不过最好的方法是使用某种一般语言和prolog结合，一般语言完成计算、界面之类的操作，而prolog则专心实现逻辑运算的操作。例如：你编写一个下棋程序，用prolog来让电脑思考如何下棋，而用Visual Basic来编写界面。我们将在以后介绍这方面的技术。 总之，prolog在许多方面将极大的减少你的编程负担，所以赶快来了解一下它吧，也许你日后遇到什么难题，可以使用prolog迎刃而解，到那个时候，你就知道今天的学习没有白费了。 prolog的特点 我个人总结了prolog的以下几个特点，因为叫做特点，所以自然要和其他的语言进行比较。 prolog程序没有特定的运行顺序，其运行顺序是由电脑决定的，而不是编程序的人 从这个意义上来说，prolog程序不是真正意义上的程序。所谓程序就是按照一定的步骤运行的计算机指令，而prolog程序的运行步骤不由人来决定。它更像一种描述型的语言，用特定的方法描述一个问题，然后由电脑自动找到这个问题的答案。举个极端的例子，你只需要把某个数学题目告诉它，它就会自动的找到答案，而不像使用其他的语言一样，必须人工的编制出某种算法。 prolog程序中没有if、when、case、for这样的控制流程语句 前面已经说了，程序的运行方式有电脑自己决定，当然就用不到这些控制流程的语句了。通常情况下，程序员不需要了解程序的运行过程，只需要注重程序的描述是否全面，不过prolog也提供了一些控制流程的方法，这些方法和其他语言中的方法有很大的区别，希望你在以后的学习当中能够融会贯通。 prolog程序和数据高度统一 在prolog程序中，是很难分清楚哪些是程序，哪些是数据的。事实上，prolog中的所有东西都有相同的形式，也就是说数据就是程序，程序就是数据。举一个其他语言的例子：如果想用c语言编写一个计算某个数学表达式的程序很简单(比如：a=2+54)，因为这是一段程序。但是如果想编写一个计算用户输入的表达式的值的程序就很困难了。因为用户输入的是一段数据(字符串)，如果想让c语言处理这个字符串，就需要很多方面的技术。则正是因为在c语言中，程序和数据是分开的。而在prolog就不存在这个问题，你甚至可以很轻松的编写处理其它prolog程序的程序。 prolog程序实际上是一个智能数据库 prolog的原理就是关系数据库，它是建立在关系数据库的基础上的。在以后的学习中你会发现它和SQL数据库查询语言有很多相似之处。使用prolog可以很方便的处理数据。 强大的递归功能 在其它的语言中，你也许已经接触过递归程序了。递归是一种非常简洁的方式，它能够有效的解决许多难题。而在prolog中，递归的功能得到了充分的体现，你甚至都会感到惊奇，递归居然又如此巨大的能力。 下一步该怎么做 好好配置运行环境 (再次提醒退出repl使用谓词halt) 然后继续读之后的章节！ Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 18:07 "},"tut/chapter1.html":{"url":"tut/chapter1.html","title":"入门","keywords":"","body":"入门 探索Prolog Prolog在英语中的意思就是Programming in LOGic（逻辑编程）。它是建立在逻辑学的理论基础之上的， 最初是运用于自然语言的研究领域。然而现在它被广泛的应用在人工智能的研究中，它可以用来建造专家系统、自然语言理解、智能知识库等。同时它对一些通常的应用程序的编写也很有帮助。使用它能够比其他的语言更快速地开发程序，因为它的编程方法更象是使用逻辑的语言来描述程序。 从纯理论的角度来讲，Prolog是一种令人陶醉的编程语言，但是在这本书中还是着重介绍他的实际使用方法。 进入Prolog世界 和其他的语言一样，最好的学习方法是实践。这本书将使用Prolog的解释器来向大家介绍几个具体的应用程序的编写过程。 首先你应该拥有一个Prolog的解释器，你可以在Google中找到它。关于解释器的使用，请参阅相关的使用说明文档，建议使用amzi prolog或者swi prolog来运行本网站的程序。 逻辑编程 什么叫逻辑编程？也许你还没有一个整体的印象，还是让我们首先来研究一个简单的例子吧。运用经典的逻辑理论，我们可以说“所有的人（person）都属于人类（moral）”，如果用Prolog的语言来说就是“对于所有的X，只要X是一个人，它就属于人类。” moral(X):- person(X). 同样，我们还可以加入一些简单的事实，比如：苏格拉底（socrates）是一个人。 person(socrates). 有了这两条逻辑声明，Prolog就可以判断苏格拉底是不是属于人类。在Prolog的Listener中键入如下的命令： ?-mortal(socrates). (此句中的?-是Listener的提示符，本句表示询问苏格拉底是不是属于人类。） Linstener将给出答案： yes 我们还可以询问，“谁属于人类？” ?- mortal(X). 我们会得到如下的答案： X= socrates 这个简单的例子显示了Prolog的一些强大的功能。它能让程序代码更简洁、更容易编写。在多数情况下Prolog的程序员不需要关心程序的运行流程，这些都由Prolog自动地完成了。 当然，一个完整的程序不能只包括逻辑运算部分，还必须拥有输入输出，乃至用户界面部分。很遗憾，Prolog在这些方面做得不好，或者说很差。不过它还是提供了一些基本的方法的。下面是上述的程序一个完整的例子。 % This is the syntax for comments. % MORTAL - The first illustrative Prolog program mortal(X) :- person(X). person(socrates). person(plato). person(aristotle). mortal_report:- write('Known mortals are:'), nl, mortal(X), write(X), nl, fail. 把这个程序调入Listener中，运行mortal_report.。 ?- mortal_report. Known mortals are: socrates plato aristotle no 以上程序中的一些函数以后还会详细的介绍的。最后的那个no表示没有其他的人了。 进入下一章 从下一章起，就开始正式介绍Prolog的编程方法了。我将用一个实例来介绍Prolog，这是一个文字的冒险游戏，你所扮演的角色是一个三岁的小女孩，你想睡觉了，可是没有毛毯（nani）你就不能安心的睡觉。所以你必须在那个大房子中找到你的毛毯，这就是你的任务。这个游戏能够显示出一些Prolog的独到之处，不过Prolog的功能远不止编个简单的游戏，所以文中还将介绍一些其他的小程序。 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"tut/chapter2.html":{"url":"tut/chapter2.html","title":"事实","keywords":"","body":"事实 事实（facts）是prolog中最简单的谓词（predicate）。它和关系数据库中的记录十分相似。在下一章中我们会把事实作为数据库来搜索。 谓词：Prolog语言的基本组成元素，可以是一段程序、一个数据类型或者是一种关系。它由谓词名和参数组成。两个名称相同而参数的数目不同的谓词是不同的谓词。 事实的语法结构如下： pred(arg1, arg2, ... argN). 其中pred为谓词的名称。arg1，...为参数，共有N个。‘.’是所有的Prolog子句的结束符。没有参数的谓词形式如下： pred. 参数可以是以下四种之一： 整数（integer): 绝对值小于某一个数的正数或负数。 原子（atom）: 由小写字母开头的字符串。 变量（variable）: 由大写字母或下划线（_）开头。 结构（structure）: 在以后的章节介绍。 不同的Prolog还增加了一些其他的数据类型，例如浮点数和字符串等。 Prolog字符集包括：大写字母，A-Z；小写字母，a-z；数字，0-9;+-/\\^,.~:.?#$等。 原子通常是字母和数字组成，开头的字符必须是小写字母。例如： hello twoWordsTogether x14 为了方便阅读，可以使用下划线把单词分开。例如： a_long_atom_name` z_23` 下面的是不合法的原子， no-embedded-hyphens 123nodigitsatbeginning Nocapsfirst 下划线不能放在最前面 使用单引号扩起来的字符集都是合法的原子。例如： 'this-hyphen-is-ok' 'UpperCase' 'embedded blanks' 下面的由符号组成的也是合法的原子： >,++ 变量和原子相似，但是开头字符是大写字母或是下划线。例如： X Input_List 下划线开头的都是变量 Z56 有了这些基本的知识，我们就可以开始编写事实了。事实通常用来储存程序所需的数据。例如，某次商业买卖中的顾客数据。customer/3。（/3表示customer有三个参数） customer('John Jones', boston, good_credit). customer('Sally Smith', chicago, good_credit). 必须使用单引号把顾客名引起来，因为它们是由大写字母开头的，并且中间有空格。 再看一个例子，视窗系统使用事实储存不同的窗口信息。在这个例子中参数有窗口名称和窗口的位置坐标。 window(main, 2, 2, 20, 72). window(errors, 15, 40, 20, 78). 某个医疗专家系统可能有如下的疾病数据库。 disease(plague, infectious). {疾病（瘟疫，有传染性）} Prolog的解释器提供了动态储存事实和规则的方法，并且也提供了访问它们的方法。数据库的更新是通过运行‘consult’或‘reconsult’命令。我们也可以直接在解释器中输入谓词，但是这些谓词不会被储存到硬盘上。 寻找Nani 下面我们正式开始“寻找Nani”游戏的编写。我们从定义基本的事实开始，这些事实是本游戏的基本的数据库。它们包括： 房间和它们的联系 物体和它们的位置 物体的属性 玩家在游戏开始时的位置 寻找Nani游戏的的房间格局如下: 首先我们使用room/1谓词定义房间，一共有五条子句，它们都是事实。 room(kitchen). room(office). room(hall). room('dining room'). room(cellar). 我们使用具有两个参数的谓词来定义物体的位置。第一个参数代表物体的名称，第二个参数表示物体的位置。开始时，我们加入如下的物体。 location(desk, office). location(apple, kitchen). location(flashlight, desk). location('washing machine', cellar). location(nani, 'washing machine'). location(broccoli, kitchen). location(crackers, kitchen). location(computer, office). 注意：我们定义的那些符号，例如：kitchen、desk等对于我们是有意义的，可是它们对于Prolog是没有任何意义的，完全可以使用任何符号来表示房间的名称。 谓词location/2的意思是“第一个参数所代表的物体位于第二个参数所代表的物体中”。Prolog能够区别location(sink, kitchen)和location(kitchen, sink)。因此，参数的顺序是我们定义事实时需要考虑的一个重要问题。 下面我们来表达房间的联系。使用door/2来表示两个房间有门相连，这里遇到了一个小小的困难： door(office, hall). 我们想要表达的意思是，office和hall之间有一个门。可是由于Prolog能够区分door(office, hall)和door(hall, office)，所以如果我们想要表达一种双向的联系，就必须把每种联系都定义一遍。 door(office, hall). door(hall, office). 参数的顺序对定义物体的位置有帮助，可是在定义房间的联系时却带来了麻烦。我们不得不把每个房门都定义两次！ 在这一章里，只定义单向的门，以后会很好地解决此问题的。 door(office, hall). door(kitchen, office). door(hall, 'dining room'). door(kitchen, cellar). door('dining room', kitchen). 下面定义某些物体的属性， edible(apple). edible(crackers). tastes_yucky(broccoli). 最后，定义手电筒（由于是晚上，玩家必须想找到手电筒，并打开它才能到那些关了灯的房间）的状态和玩家的初始位置。 turned_off(flashlight). here(kitchen). 好了，到此你应该学会了如何使用Prolog的事实来表达数据了。 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"tut/chapter3.html":{"url":"tut/chapter3.html","title":"简单查询","keywords":"","body":"简单查询 现在我们的游戏中已经有了一些事实，使用Prolog的解释器调入此程序后，我们就可以对这些事实进行查询了。本章和下一章中的Prolog程序只包括事实，我们要学会如何对这些事实进行查询。 Prolog的查询工作是靠模式匹配完成的。查询的模板叫做目标(goal)。如果有某个事实与目标匹配，那么查询就成功了，Prolog的解释器会回显'yes.'。如果没有匹配的事实，查询就失败了，解释器回显'no.'。 我们把Prolog的模式匹配工作叫做联合(unification)。当数据库中只包括事实时，以下三个条件是使联合成功的必要条件。 目标谓词名与数据库中的某个谓词名相同。 这两个谓词的参数数目相同。 所有的参数也相同。 在介绍查询之前，让我们回顾一下上一章所编写的Prolog程序。 room(kitchen). room(office). room(hall). room('dining room'). room(cellar). door(office,hall). door(kitchen,office). door(hall,'dining room'). door(kitchen,cellar). door('dining room',kitchen). location(desk,office). location(apple,kitchen). location(flashlight,desk). location('washing machine',cellar). location(nani,'washing machine'). location(broccoli,kitchen). location(crackers,kitchen). location(computer,office). edible(apple). edible(crackers). tastes_yucky(broccoli). here(kitchen). 以上是我们的“寻找Nani”中的所有事实。把这段程序调入Prolog解释器中后就可以开始进行查询了。 我们的第一个问题是：office在本游戏中是不是一个房间。 ?-room(office). yes. Prolog回答yes，因为它在数据库中找到了room(office).这个事实。我们继续问：有没有attic这个房间。 ?-room(attic). no. Prolog回答no，因为它在数据库中找不到room(attic).这个事实。同样我们还可以进行如下的询问。 ?- location(apple, kitchen). yes ?- location(kitchen, apple). no 你看Prolog懂我们的意思呢，它知道苹果在厨房里，并且知道厨房不在苹果里。但是下面的询问就出问题了。 ?- door(office, hall). yes ?- door(hall, office). no 由于我们定义的门是单方向的，结果遇到了麻烦。 在查询目标中我们还可以使用Prolog的变量。这种变量和其他语言中的不同。叫它逻辑变量更合适一点。变量可以代替目标中的一些参数。 变量给联合操作带来了新的意义。以前联合操作只有在谓词名和参数都相同时才能成功。但是引入了变量之后，变量可以和任何的条目匹配。 当联合成功之后，变量的值将和它所匹配的条目的值相同。这叫做变量的绑定(binding)。当带变量的目标成功的和数据库中的事实匹配之后，Prolog将返回变量绑定的值。 由于变量可能和多个条目匹配，Prolog允许你察看其他的绑定值。在每次Prolog的回答后输入“；”，可以让Prolog继续查询。下面的例子可以找到所有的房间。“；”是用户输入的。 ?- room(X). X = kitchen ; X = office ; X = hall ; X = 'dining room' ; X = cellar ; no 最后的no表示找不到更多的答案了。 下面我们想看看kitchen中都有些什么。（变量以大写字母开始） ?- location(Thing, kitchen). Thing = apple ; Thing = broccoli ; Thing = crackers ; no 我们还可以使用两个变量来查询所有的物体及其位置。 ?- location(Thing, Place). Thing = desk Place = office ; Thing = apple Place = kitchen ; Thing = flashlight Place = desk ; //... no 查询的工作原理 当Prolog试图与某一个目标匹配时，例如：location/2，它就在数据库中搜寻所有用location/2定义的子句，当找到一条与目标匹配时，它就为这条子句作上记号。当用户需要更多的答案时，它就从那条作了记号的子句开始向下查询。 我们来看一个例子，用户询问：location（X，kitchen）.。Prolog找到数据库中的第一条location/2子句，并与目标比较。 目标location(X, kitchen) 子句#1 location(desk, office) 匹配失败，因为第二个参数不同，一个是kitchen，一个是office。于是Prolog继续比较第二个子句。 目标location(X, kitchen) 子句#2 location(apple, kitchen) 这回匹配成功，而变量X的值就被绑定成了apple。 ?- location(X, kitchen). X = apple 如果用户输入分号(;)，Prolog就开始寻找其他的答案。首先它必须释放（unbinds）变量X。然后从上一次成功的位置的下一条子句开始继续搜索。这个过程叫做回溯（backtracking）。在本例中就是第三条子句。 目标location(X, kitchen) 子句#3 location(flashlight, desk) 匹配失败，直到第六条子句时匹配又成功了。 目标location(X, kitchen) 子句#6 location(broccoli, kitchen) 结果变量X又被绑定为broccoli，解释器显示： X = broccoli ; 再度输入分号，X又被解放，开始新的搜索。又找到了： X = crackers ; 这回再没有新的子句能够匹配了，于是Prolog回答no，表示最后一次搜索失败了。 no 要想了解Prolog的运行顺序，最好的方法就是单步调试程序，不过在此之前，还是让我们加深一下对目标的认识吧。 Prolog的目标有四个端口用来控制运行的流程：调用（call）、退出（exit）、重试（redo）以及失败（fail）。一开始使用Call端口进入目标，如果匹配成功就到了exit端口，如果失败就到了fail端口，如果用户输入分号，则又从redo端口进入目标。下图表示了目标和它的四个端口。 每个端口的功能如下： call开始使用目标搜寻子句。 exit目标匹配成功，在成功的子句上作记号，并绑定变量。 redo试图重新满足目标，首先释放变量，并从上次的记号开始搜索。 fail表示再找不到更多的满足目标的子句了。 下面列出了调试location(X,kitchen).时的情况。括号中的数字表示当前正在考虑的子句。 ?- location(X, kitchen). CALL: - location(X, kitchen) EXIT:(2) location(apple, kitchen) X = apple; REDO: location(X, kitchen) EXIT:(6) location(broccoli, kitchen) X = broccoli ; REDO: location(X, kitchen) EXIT:(7) location(crackers, kitchen) X = crackers ; FAIL - location(X, kitchen) no Debug 在Prolog的解释器中输入， ?- debug. 就可以开始调试你的程序了。 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"tut/chapter4.html":{"url":"tut/chapter4.html","title":"混合查询","keywords":"","body":"混合查询 我们可以把简单的查询连接起来，组成一些较复杂的查询。例如，如果我们想知道厨房里能吃的东西，就可以向Prolog进行如下的询问。 ?- location(X, kitchen), edible(X). 简单的查询只有一个目标，而混合查询可以把这些目标连接起来，从而进行较为复杂的查询。上面的连接符号','是并且的意思。 上面的式子用语言来描述就是“寻找满足条件的X，条件是：X在厨房里，并且X能吃。”如果某个变量在询问中多次出现，则此变量在所有出现的位置都必须绑定为相同的值。所以上面的查询只有找到某一个X的值，使得两个目标都成立时，才算查询成功。 每次查询所使用的变量都是局部的变量，它只在本查询中有意义，所以当我们进行了如下的查询后， ?- location(X, kitchen), edible(X). X = apple ; X = crackers ; no 查询结果中没有broccoli（椰菜），因为我们没有把它定义为可吃的东西。此后，还可以用X进行其他的查询。 ?- room(X). X = kitchen ; X = office ; X = hall ; ...; no 除了使用逻辑的方法理解混合查询外，还可以通过分析程序的运行步骤来理解。用程序的语言来说就是“首先找到一样位于厨房的东西，然后判断它能否食用，如果不能，就到厨房里找下一样东西，再判断能否食用。一直如此重复，直到找到答案或把厨房的东西全部查完为止。” 请参照下图来理解。 调用查询后，程序将按照下面的步骤运行，请参照上图来理解。 搜索第一个目标，如果成功转到2，如果失败则回答'no'，查询结束。 搜索第二个目标，如果成功转到3，如果失败转到1。 把绑定的变量的值输出。用户输入';'后转到2。 上面的例子中只有一个变量，下面我们再来看一个有两个变量的例子。 ?- door(kitchen, R), location(T,R). R = office T = desk ; R = office T = computer ; R = cellar T = 'washing machine' ; no 上面的查询用逻辑的语言来解释就是：“找房间R，使得从厨房到房间R有门相连，并且把房间R中的物品T(这里是房间R的所有物品）也找出来。” 下面是此查询的单步运行过程。 Goal: door(kitchen, R), location(T,R) 1 CALL door(kitchen, R) 1 EXIT (2) door(kitchen, office) 2 CALL location(T, office) 2 EXIT (1) location(desk, office) R = office T = desk ; 2 REDO location(T, office) 2 EXIT (8) location(computer, office) R = office T = computer ; 2 REDO location(T, office) 2 FAIL location(T, office) 1 REDO door(kitchen, R) 1 EXIT (4) door(kitchen, cellar) 2 CALL location(T, cellar) 2 EXIT (4) location('washing machine', cellar) R = cellar T = 'washing machine' ; 2 REDO location(T, cellar) 2 FAIL location(T, cellar) 1 REDO door(kitchen, R) 1 FAIL door(kitchen, R) no 内部谓词 讲了这么多了，我们还只是用到了Prolog的一些语法，完全没有使用Prolog提供的一些内部的函数，我把这些内部函数称为内部谓词。和其他的程序语言一样，Prolog也提供了一些基本的输入输出函数，下面我们要编写一个较复杂的查询，它能够找到所有厨房里能够吃的东西，并把它们列出来。而不是像以前那样需要人工输入';'。 要想完成上面的任务，我们首先必须了解内部谓词的概念。内部谓词是指已经在Prolog中事先定义好的谓词。在内存中的动态数据库中是没有内部谓词的子句的。当解释器遇到了内部谓词的目标，它就直接调用事先编好的程序。 内部谓词一般所完成的工作都是与逻辑程序无关的，例如输入输出的谓词。所以我们可以把这些谓词叫做非逻辑谓词。 但是这些谓词也可以作为Prolog的目标，所以它们也必须拥有和逻辑谓词相同的四个端口：Call、Fail、Redo和Exit。 下面介绍几个常用的输出谓词。 write/1 此谓词被调用时永远是成功的，并且它可以把它的参数作为字符串输出到屏幕上。当回溯时，它永远是失败，所以回溯是不会把已经写到屏幕上的字符又给删除的。 nl/0 此谓词没有参数，和write一样，从Call端口调用时总是成功的，从Redo端口回溯时总是失败的，它的作用是在屏幕上输出一个回车符。 tab/1 此谓词的参数是一个整数，它的作用是输出n个空格，n为它的参数。其控制流程与上面两个相同。 下图是一般情况下的Prolog目标的内部流程控制示意图。我们将使用此图和内部谓词的流程控制图相比较。 上图中左上角的菱形方块表示从`Call`端口进入目标时所进行的处理。它从某谓词的第一个子句开始搜索，如果匹配成功就到`Exit`端口，如果没有找到任何一个子句与目标匹配就转到`Fail`端口。 右下角的方块表示从`Redo`端口进入目标时所进行的处理，从最近一次成功的子句开始向下搜索，如果匹配成功就转到`Exit`端口，如果没有找个更多的子句满足目标就转到`Fail`端口。 `I/O`谓词的流程控制和上述的不同，它不会改变流程的方向，如果流程从它的左边进入，就会从它的右边流出；而如果从它的右边进入，则会从它的左边流出。请参考下图理解。 I/O谓词不会改变变量的值，但是它们可以把变量的值输出。 还有一个专门引起回溯的内部谓词fail/0，从它的名字不难看出，它的调用永远是失败的。如果fail/0从左边得到控制权，则它立即把控制权再传回到左边。它不会从右边得到控制，因为没法通过fail/0把控制权传到右侧。它的内部流程控制如下： 以前我们是靠使用';'来进入目标的Redo端口的，并且变量的值的输出是靠解释器完成的。现在有了上面几个内部谓词，我们就可以靠I/O谓词来显示变量的值，靠fail谓词来引起自动的回溯。 下面是此查询语句及其运行结果。 ?- location(X, kitchen), write(X) ,nl, fail. apple broccoli crackers no 下面是此查询的流程图。 下面是此查询的单步调试过程。 Goal: location(X, kitchen), write(X), nl, fail. 1 CALL location(X, kitchen) 1 EXIT (2) location(apple, kitchen) 2 CALL write(apple) apple 2 EXIT write(apple) 3 CALL nl 3 EXIT nl 4 CALL fail 4 FAIL fail 3 REDO nl 3 FAIL nl 2 REDO write(apple) 2 FAIL write(apple) 1 REDO location(X, kitchen) 1 EXIT (6) location(broccoli, kitchen) 2 CALL write(broccoli) broccoli 2 EXIT write(broccoli) 3 CALL nl 3 EXIT nl 4 CALL fail 4 FAIL fail 3 REDO nl 3 FAIL nl 2 REDO write(broccoli) 2 FAIL write(broccoli) 1 REDO location(X, kitchen) 1 EXIT (7) location(crackers, kitchen) 2 CALL write(crackers) crackers 2 EXIT write(crackers) 3 CALL nl 3 EXIT nl 4 CALL fail 4 FAIL fail 3 REDO nl 3 FAIL nl 2 REDO write(crackers) 2 FAIL write(crackers) 1 REDO location(X, kitchen) 1 FAIL location(X, kitchen) no after 下面请你分析一下， ?- door(kitchen, R), write(R), nl, location(T,R), tab(3), write(T), nl, fail. 的输出的结果是什么呢？ Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"tut/chapter5.html":{"url":"tut/chapter5.html","title":"规则","keywords":"","body":"规则 前面我们已经说过，谓词是使用一系列的子句来定义的。以前我们所学习的子句是事实，现在让我们来看看规则吧。规则的实质就是储存起来的查询。它的语法如下： head :- body 其中， head是谓词的定义部分，与事实一样，也包括谓词名和谓词的参数说明。 :-连接符，一般可以读作‘如果’。 body一个或多个目标，与查询相同。 举个例子，上一章中的混合查询--找到能吃的东西和它所在的房间，可以使用如下的规则保存，规则名为where_food/2。where_food(X,Y) :- location(X,Y), edible(X). 用语言来描述就是“在房间Y中有可食物X的条件是：X在Y房间中，并且X可食。” 我们现在可以直接使用此规则来找到房间中可食的物品。 ?- where_food(X, kitchen). X = apple ; X = crackers ; no ?- where_food(Thing, 'dining room'). no 它也可以用来判断， ?- where_food(apple, kitchen). yes 或者通过它找出所有的可食物及其位置， ?- where_food(Thing, Room). Thing = apple Room = kitchen ; Thing = crackers Room = kitchen ; no 我们可以使用多个事实来定义一个谓词，同样我们也可以用多个规则来定义一个谓词。例如，如果想让Prolog知道broccoli（椰菜）也是可食物，我们可以如下定义where_food/2规则。 where_food(X,Y) :- location(X,Y), edible(X). where_food(X,Y) :- location(X,Y), tastes_yucky(X). 在以前的事实中我们没有把broccoli定义为edible，即没有edible(broccoli).这个事实，所以单靠where_food的第一个子句是不能找出broccoli的，但是我们曾在事实中定义过：tastes_yucky(broccoli).，所以如果加入第二个子句，Prolog就可以知道broccoli也是food（食物）了。下面是它的运行结果。 ?- where_food(X, kitchen). X = apple ; X = crackers ; X = broccoli ; no 规则的工作原理 到现在为止，我们所知道的Prolog所搜索的子句只有事实。下面我们来看看Prolog是如何搜索规则的。 首先，Prolog将把目标和规则的子句的头部（head）进行匹配，如果匹配成功，Prolog就把此规则的body部分作为新的目标进行搜索。 实际上规则就是多层的询问。第一层由原始的目标组成，从下一层开始就是由与第一层的目标相匹配的规则的Body中的子目标组成。（这句话有点难理解，请参照下面图来分析） 每一层还可以有子目标，理论上来讲，这种目标的嵌套可以是无穷的。但是由于计算机的硬件限制，子目标只可能有有限次嵌套。 下图显示了这种目标嵌套的流程图，请你注意第一层的第三个目标是如何把控制权回溯到第二层的子目标中的。 在这个例子中，第一层的中间的那个目标的结果依赖于第二层的目标的结果。此目标会把程序的控制权传给他的子目标。 下面我们详细地分析一下Prolog在匹配有规则的子句时是如何工作的。请注意用‘-’分隔的两个数字，第一个数字代表当前的目标级数，第二个数字代表当前目标层中正在匹配的目标的序号。例如： 2-1 EXIT (7) location(crackers, kitchen) 表示第二层的第一个目标的EXIT过程。 我们的询问如下 ?- where_food(X, kitchen). 首先我们寻找有where_food/2的子句. 1-1 CALL where_food(X, kitchen) 与第一个子句的头匹配 1-1 try (1) where_food(X, kitchen) ; 第一个where_food/2的子句与目标匹配。 于是第一个子句的Body将变为新的目标。 2-1 CALL location(X, kitchen) 从现在起的运行过程就和我们以前一样了。 2-1 EXIT (2) location(apple, kitchen) 2-2 CALL edible(apple) 2-2 EXIT (1) edible(apple) 由于Body的所有目标都成功了，所以第一层的目标也就成功了。 1-1 EXIT (1) where_food(apple, kitchen) X = apple ; 第一层的回溯过程使得又重新进入了第二层的目标。 1-1 REDO where_food(X, kitchen) 2-2 REDO edible(apple) 2-2 FAIL edible(apple) 2-1 REDO location(X, kitchen) 2-1 EXIT (6) location(broccoli, kitchen) 2-2 CALL edible(broccoli) 2-2 FAIL edible(broccoli) 2-1 REDO location(X, kitchen) 2-1 EXIT (7) location(crackers, kitchen) 2-2 CALL edible(crackers) 2-2 EXIT (2) edible(crackers) 1-1 EXIT (1) where_food(crackers, kitchen) X = crackers ; 下面就没有更多的答案了，于是第一层的目标失败。 2-2 REDO edible(crackers) 2-2 FAIL edible(crackers) 2-1 REDO location(X, kitchen) 2-1 FAIL location(X, kitchen) 下面Prolog开始寻找另外的子句，看看它们的头部（head）能否与目标匹配。在此例中，where_food/2的第二个子句也可以与询问匹配。 1-1 REDO where_food(X, kitchen) Prolog又开始试图匹配第二个子句的Body中的目标。 1-1 try (2) where_food(X, kitchen) ; 第二个where_food/2的子句与目标匹配。 下面将找到不好吃的椰菜。即tastes_yucky的broccoli. 2-1 CALL location(X, kitchen) 2-1 EXIT (2) location(apple, kitchen) 2-2 CALL tastes_yucky(apple) 2-2 FAIL tastes_yucky(apple) 2-1 REDO location(X, kitchen) 2-1 EXIT (6) location(broccoli, kitchen) 2-2 CALL tastes_yucky(broccoli) 2-2 EXIT (1) tastes_yucky(broccoli) 1-1 EXIT (2) where_food(broccoli, kitchen) X = broccoli ; 回溯过程将让Prolog寻找另外的where_food/2的子句。但是，这次它没有找到。 2-2 REDO tastes_yucky(broccoli) 2-2 FAIL tastes_yucky(broccoli) 2-1 REDO location(X,kitchen) 2-1 EXIT (7) location(crackers, kitchen) 2-2 CALL tastes_yucky(crackers) 2-2 FAIL tastes_yucky(crackers) 2-2 REDO location(X, kitchen) 2-2 FAIL location(X, kitchen) 1-1 REDO where_food(X, kitchen) ; 没有找到更多的where_food/2的子句了。 1-1 FAIL where_food(X, kitchen) no 在询问的不同层的目标中，即是相同的变量名称也是不同的变量，因为它们都是局部变量。这于其他语言中的局部变量是差不多的。 我们再来分析一下上面的那个例子吧。 where_food(X,Y) :- location(X,Y), edible(X). 查询的目标是： ?- where_food(X1, kitchen) 第一个子句的头是： where_food(X2, Y2) 目标和子句的头部匹配，在Prolog中如果变量和原子匹配，那么变量就绑定为此原子的值。如果两个变量进行了匹配，那么这两个变量将同时绑定为一个内部变量。此后，这两个变量中只要有一个绑定为了某个原子的值，另外一个变量也会同时绑定为此值。所以上面的匹配操作将有如下的绑定。 X1 = _01 ; % 01 为Prolog的内部变量。 X2 = _01 Y2 = kitchen 于是当上述的匹配操作完成后，规则where_food/2的body将变成如下的查询： location(_01, kitchen), edible(_01). 当内部变量取某值时，例如'apple'，X1和X2将同时绑定为此值，这是Prolog变量和其他语言的变量的基本的区别。如果你学过C语言，容易看出，实际上X1和X2都是指针变量，当它们没有绑定值时，它们的值为NULL，一旦绑定，它们就会指向某个具体的位置，上例中它们同时指向了_01这个变量，其实_01变量还是个指针，直到最后某个指针指向了具体的值，那么所有的指针变量就都被绑定成了此值。 使用规则 使用规则我们可以很容易的解决单向门的问题。我们可以再定义有两个子句的谓词来描述这种双向的联系。此谓词为connect/2。 connect(X,Y) :- door(X,Y). connect(X,Y) :- door(Y,X). 它代表的意思是“房间X和Y相连的条件是：从X到Y有扇门，或者从Y到X有扇门\"。请注意此处的或者，为了描述这种或者的关系我们可以为某个谓词定义多个子句。 ?- connect(kitchen, office). yes ?- connect(office, kitchen). yes 我们还可以让Prolog列出所有相连的房间。 ?- connect(X,Y). X = office Y = hall ; X = kitchen Y = office ; ... X = hall Y = office ; X = office Y = kitchen ; // ... 使用我们现在所具有的知识，我们可以为“搜索Nani”加入更多的谓词。首先我们定义look/0，它能够显示玩家所在的房间，以及此房间中的物品和所有的出口。 先定义list_things/1，它能够列出某个房间中的物品。 list_things(Place) :- location(X, Place), tab(2), write(X), nl, fail. 它和上一章中的最后一个例子差不多。我们可以如下使用它。 ?- list_things(kitchen). apple broccoli crackers no 这地方有一个小问题，它虽然把所有的东西都列出来了，但是最后那个no不太好看，并且如果我们把它和其他的规则连起来用时麻烦就更大了，因为此规则的最终结果都是fail。实际上它是我们扩充的I/O谓词，所以它应该总是成功的。我们可以很容易的解决这个问题。 list_things(Place) :- location(X, Place), tab(2), write(X), nl, fail. list_things(AnyPlace). 如上所示，加入list_things(AnyPlace)子句后就可以解决了，第一个list_things/1的子句把所有的物品列出，并且失败，而由于第二个子句永远是成功的，所以list_things/1也将是成功的。AnyPlace变量的值我们并不关心，所以我们可以使用无名变量‘_’来代替它。 list_things(_). 下面我们来编写list_connections/1，它能够列出与某个房间相连的所有房间。 list_connections(Place) :- connect(Place, X), tab(2), write(X), nl, fail. list_connections(_). 我们来试试功能， ?- list_connections(hall). dining room office yes 终于可以来编写look/0了， look :- here(Place), write('You are in the '), write(Place), nl, write('You can see:'), nl, list_things(Place), write('You can go to:'), nl, list_connections(Place). 在我们定义的事实中有here(kitchen).它代表玩家所在的位置。以后我们将学习如何改变此事实。现在来试是功能吧， ?- look. You are in the kitchen You can see: apple broccoli crackers You can go to: office cellar dining room yes 好了到此，我们已经学会了Prolog的基本编程方法，下一章将总结一下，并再举几个例子，此后我们将进入较深的学习。 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"tut/chapter6.html":{"url":"tut/chapter6.html","title":"小结","keywords":"","body":"小结 到现在为止，我们已经对Prolog有了一个基本的了解，现在有必要对我们所学过的知识做一个系统的总结。 Prolog的程序是由一系列的事实和规则组成的数据库。 规则之间的调用是通过联合操作完成的，Prolog能够自动的完成模式匹配。 规则还可以调用内部谓词，例如write/1。 我们可以在Prolog的解释器中单独地对规则进行查询（调用）。 在Prolog的程序的运行流程方面我有了如下的认识： 规则的运行是通过Prolog内建的回溯功能实现的。 我们可以使用内部谓词fail来强制实现回溯。 我们也可以通过加入一条参数为伪变量（下划线）无Body部分的子句，来实现强制让谓词成功。 我们还学习了， 数据库中的事实代替了一般语言中的数据结构。 回溯功能能够完成一般语言中的循环操作。 而通过模式匹配能够完成一般语言中的判断操作。 规则能够被单独地调试，它和一般语言中的模块相对应。 而规则之间的调用和一般语言中的函数的调用类似。 有了以上的知识，我们还可以编写出一些让其它语言的程序员吃惊的小程序。下面就举一个分析家谱的程序。 假如我们把家族成员之间的父子关系和夫妻关系，以及成员的性别属性定义为基本的事实数据库，我们就可以编出许多规则来判断其他的亲戚关系了。 例如我们有如下的数据库： father(a,b). father(a,d). father(a,t). father(b,c). wife(aw,a). wife(bw,b). male(t). female(d). male(c). father(a,b).表示a是b的父亲。 wife(aw,a). 表示aw是a的妻子。 male(t).表示b是男性。 female(d).表示d是女性。 上面我们并没有定义a、b、aw、bw的性别。因为通过他们和其他人的关系我们可以很容易地确定他们的性别。不过要想让Prolog知道他们的性别我们就要定义如下的规则。 male(X):-father(X,_). female(X):-wife(X,_). 上面的male/1和female/1的谓词名称和事实的名称相同，这并不是什么特别的情况，你可以把所有定义相同的谓词的子句之间的关系想象“或者”的关系。也就是说：t和d是男性，或者如果X是其他人的父亲，则它也是男性。在判断性别时，我们并不关心此人是谁的父亲，所以后面一个变量用“_”代替了。 好了，假如有如下的询问： ?-male(t). yes. ?-male(a). yes. ?-male(X). X=t; X=c; X=a; X=a; X=a; X=b; no. 最后一个询问，它虽然把所有的男性找了出来，可是它把a找了三次，原因很简单，因为我们有三个father/2的子句都包含a，好像不太理想，不过现在只能将就一下了，当我们学习了更多的知识后，就好解决了。 下面我们定义一些其他的亲戚关系的规则。你大概一看就能够理解。例如：X和Y是兄弟的条件是: X和Y有相同的父亲{father(Z,X),father(Z,Y)}，并且他们都是男性{male(X),male(Y)}，最后由于X和Y可以取相同的值，所以我们不得不加上一条X和Y不是同一个人。 grandfather(X,Y):- father(X,Z), father(Z,Y). mother(X,Y):- wife(X,Z), father(Z,Y). brother(X,Y):- father(Z,X), father(Z,Y), male(X), male(Y), X\\=Y. 当然我们还可以加入更复杂一点的规则， uncle(X,Y):- brother(X,Z), father(Z,Y). 这个叔伯的规则uncle/2调用了前面的规则brother/2。 这里只是简单回顾一下前面所学习的知识，所以这个家族程序虽然可以使用，但是却极不完善。例如：它会把某一答案重复多次，还不能描述没有小孩的丈夫的性别。我们这样改一下会更好一点：male(X):-wife(_,X)。因此，规则的定义是多种多样的，到底哪种更好、哪种更快，这就是我们以后所要研究的问题之一了。 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 17:39 "},"codeseen/":{"url":"codeseen/","title":"庖丁解牛","keywords":"","body":"庖丁解牛 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 16:18 "},"codeseen/codeseen1.html":{"url":"codeseen/codeseen1.html","title":"bencode","keywords":"","body":"bencode 在油管看到一个prolog的讲座说到了它在特殊领域的优势 其中就提到了通过逻辑编程来实现bencode的解析工作 于是乎找来看了看 https://github.com/mndrix/bencode 我曾经尝试过用py实现bencode解析器 说实话，编码上没感觉pl有什么优势，反倒更啰嗦 但是对于逻辑上的正确性却是出奇的高的 单纯和py比较的话，py写代码需要十份时间，而调试需要一百份时间 pl的话，花九十份时间写完代码，就能直接跑了，基本不会有问题 code thinking Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 16:44 "},"AFTERME.html":{"url":"AFTERME.html","title":"后语","keywords":"","body":"后语 Copyright © zhzluker96 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-01-08 18:28 "}}